# Опасности экспоненты  
## Tribonacci T(n): от экспоненты к логарифму

Этот проект — учебный и демонстрационный.  
Он показывает, **почему экспоненциальные алгоритмы непригодны**, и как одну и ту же задачу можно решить:

- линейно
- линейно с памятью
- логарифмически

на примере **чисел трибоначчи**.

---

## Что такое числа трибоначчи

Последовательность задаётся так:

```

T(0) = 0
T(1) = 0
T(2) = 1
T(n) = T(n-1) + T(n-2) + T(n-3)

```

Числа растут очень быстро, поэтому:

- точное значение помещается в `int64_t` только до `n ≈ 74`
- дальше приходится считать **по модулю**

В программе это учитывается автоматически.

---

## Что делает программа

Для введённого `n` программа:

1. Считает `T(n)` **точно в `int64`**, пока это возможно
2. При переполнении автоматически переходит на вычисление  
   `T(n) mod 1_000_000_007`
3. Сравнивает **три разных алгоритма**
4. Замеряет время каждого метода
5. Проверяет, что результаты совпадают

---

## Сравнение методов

| Метод | Идея | Время | Память | Когда использовать |
|------|------|-------|--------|-------------------|
| Итерация (rolling 3) | Храним только последние 3 значения | **O(N)** | **O(1)** | Лучший выбор для одного `T(n)` |
| DP-таблица (tabulation) | Храним `T(0..n)` | **O(N)** | **O(N)** | Когда нужны **все значения** |
| Матрица 3×3 + fast power | Возведение матрицы в степень | **O(log N)** | **O(1)** | Очень большие `n`, особенно по модулю |

> ⚠️ Экспоненциальный рекурсивный алгоритм **специально не используется**,  
> потому что он становится непригодным уже при `n ≈ 40`.

---

## Пример работы

```

Введите n (или clean/q/Enter): 1000

Вы ввели n = 1 000

1. Iteration (exact->mod): 0 ms
2. DP table (exact->mod): 0 ms
3. Matrix (exact->mod): 0 ms

T(1 000) results:

1. Iteration:
   exact int64     = (overflow from n = 75)
   mod (NOT exact) = 78728823
   compare value   = 78728823

2. DP table:
   exact int64     = (overflow from n = 75)
   mod (NOT exact) = 78728823
   compare value   = 78728823

3. Matrix:
   exact int64     = (overflow inside method)
   mod (NOT exact) = 78728823
   compare value   = 78728823

OK: compare values match (exact%MOD == mod).

```

---

## Управление программой

- Ввод числа:  
```

1000000
1 000 000
1_000_000

````
- `Enter` — очистить экран (шапка остаётся)
- `q` или `exit` — выход

---

## Windows (MinGW): PATH и UTF-8

### Добавление MinGW в PATH (если `g++` не найден)

Временно (в текущей консоли):

```bat
set PATH=C:\Qt\Tools\mingw1310_64\bin;%PATH%
````

---

### Включение UTF-8 (чтобы корректно выводился русский текст)

```bat
chcp 65001
```

---

### Компиляция и запуск

```bat
g++ -O2 -std=c++17 tribonacci.cpp -o trib.exe
trib.exe
```

---

## Альтернативы `chcp 65001`

### 1) Windows Terminal / PowerShell

В Windows Terminal UTF-8 обычно включён по умолчанию.

В PowerShell можно явно задать:

```powershell
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8
```

---

### 2) Установка кодировки прямо в коде (Windows)

```cpp
#ifdef _WIN32
#include <windows.h>
#endif

int main() {
#ifdef _WIN32
    SetConsoleOutputCP(CP_UTF8);
    SetConsoleCP(CP_UTF8);
#endif
    ...
}
```

---

## Зачем этот проект

* Понять, **почему экспоненциальная сложность — зло**
* Увидеть разницу между `O(N)` и `O(log N)` на практике
* Научиться:

  * отслеживать переполнение
  * корректно сравнивать алгоритмы
  * писать честные бенчмарки

---

## Лицензия

MIT / Public Domain — используй для обучения и экспериментов.

---

## Очистка строки ввода (ANSI escape codes)

Для аккуратного интерфейса программа **стирает строку ввода после нажатия Enter**,  
чтобы вместо

Введите n: 1000

оставалось только

Вы ввели n = 1 000

Для этого используются **ANSI escape codes**:

```cpp
"\x1b[1A\x1b[2K\r"
Что они делают:

\x1b[1A — подняться на одну строку вверх

\x1b[2K — очистить всю строку

\r — вернуться в начало строки

⚠️ Важно:

Это работает в Windows Terminal, PowerShell, Linux/macOS терминалах

Может не работать в старом cmd.exe без поддержки ANSI

Логика программы не зависит от этого механизма — это только UI-улучшение

Если ANSI не поддерживается, программа всё равно корректно работает,
просто строка ввода не стирается визуально.